%
% Method
%

% !TEX root = ../../main.tex

\chapter{Methode}

  \section{Design der Individuen}

    Der Ansatz für das Design der Individuen ist an \Glspl{Hexapod} angelehnt.
    Dabei sind viele Eigenschaften der Ameise in den Entwurf eingeflossen.
    Sie bieten mit ihren 6 Beinen eine gute Kombination aus Stabilität und Einfachheit der Steuerung.

    \subsection{Körper\label{sub:DesignBody}}

      Die Form des Körpers soll frei evolvierbar sein.
      Deshalb wird der Körper eines Individuums als Polygon mit n Punkten beschrieben.
      \\
      Als Einschränkung wird festgelegt, dass ein Polygon aus minimal 4 und maximal 8 Punkte generiert wird.
      Diese Bedingung beschränkt sowohl den Rechenaufwand der Berechnung des Körpers während der Simulation,
      als auch in der Mutationsphase.
      Weiter wird festgelegt, dass das Polygon ein \gls{SimplePolygon} sein muss.
      Ohne diese Bedingung könnten Körper generiert werden, deren Kanten sich überkreuzen.
      Solche Körper werden als ungültig erachtet, da diese in der Natur nicht vorkommen.

      \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
          \input{graphics/concept-body-n6}
          \caption{6 Punkte\label{fig:ConceptBodyPoints6}}
        \end{subfigure}
        \qquad
        \begin{subfigure}[b]{0.3\textwidth}
          \input{graphics/concept-body-n8}
          \caption{8 Punkte\label{fig:ConceptBodyPoints8}}
        \end{subfigure}
        \caption{Konzept Körper\label{fig:ConceptBodyPoints}}
      \end{figure}

      \subsubsection{Hypothese Körperpunkte\label{subsub:hypoKp}}

        Es wird die Hypothese aufgestellt,
        dass sich ein Individuum mit 8 Körperpunkten schneller durch den Parcours bewegt,
        als ein Individuum mit weniger Körperpunkten.
        Die Vermutung dabei ist, dass durch die komplexere Form des Individuums die Balance besser gehalten werden kann.
        Im Kapitel~\ref{chap:Resultate} werden die Resultate diskutiert.

    \subsection{Beine\label{sub:Beine}}

      Da als Grundkonzept ein \gls{Hexapod} verwendet wird, wird auch die Eigenschaft übernommen,
      dass das Individuum 6 Beine besitzt.
      Analog zu einer Ameise werden die Beine in 3 symmetrische Beinpaare aufgeteilt.
      \\
      Technisch bietet sich die Möglichkeit die Beine nicht in Paare zu gliedern und asymmetrisch am Körper anzubringen.
      Doch in der Natur existiert eine solche Anordnung nicht, weshalb darauf verzichtet wird.
      \\
      Ein Bein ist unterteilt in Oberschenkel \(T\) und Unterschenkel \(S\).
      Die Höhe \(h_{l}\) und Breite \(w_{l}\) des Beins sind limitiert.
      Andernfalls ist anzunehmen, dass ungewünschte Resultate entstehen~\vref{sub:IntroReqLimit}.
      \\
      Im Genom bestimmt der Wert des Höhenfaktors \(h_{f}\)
      wie das Verhältnis der Länge von Unterschenkel \(h_{s}\) zu Oberschenkel \(h_{t}\) ist.
      Die Schenkel sind durch das Kniegelenk \(j_{k}\) miteinander verbunden.
      Mit dem Hüfgelenk \(j_{h}\) wird das Bein mit dem Körper verbunden.
      Für die Position des Hüftgelenkes existiert die Bedinung,
      dass das Gelenk innerhalb der Körperfläche angebracht sein muss.
      Zur Vereinfachung wird die Höhe jedes Gelenkes auf 0 festgelegt.

      \begin{figure}[H]
        \centering
        \input{graphics/concept-leg}
        \caption{Konzept Bein\label{fig:conceptLeg}}
      \end{figure}

      \subsubsection{Masse\label{subsub:Mass}}

        Das ganze Individuum hat eine konstante Masse \(m\) von 1.
        Diese Masse wird auf die einzelnen Körperteile aufgeteilt.
        Als Verteilschlüssel dient die Fläche eines Teiles.

        \paragraph{Beispiel\label{par:MassExample}}

          Sei die Fläche eines Körpers \(a_{b} = 2 \) und die eines Beines jeweils \(a_{l} = 1\),
          dann werden die Massen \(m_{b}\) und \(m_{l}\) wie folgt berechnet:

          \begin{gather*}
            m = 1, a_{l} = 1, a_{b} = 2 \\
            a = a_{l} * 6 + a_{b} = 8 \\
            x = m / a = 0.125 \\
            m_{l} = x * a_{l} = 0.125 \\
            m_{b} = x * a_{b} = 0.25
          \end{gather*}

    \subsection{Genotyp\label{sub:Genotype}}

      \subsubsection{Design\label{subsub:GenotypeDesign}}

        Der Anspruch an das Design des Genotyps ist möglichst modular und einfach zu sein.
        Als Grund für ein modulares Design spricht die Erweiterbarkeit und Wiederverwendung der bestehenden Teile.
        Deshalb wurde der Genotyp in Teil-Genotypen unterteilt.
        Ein Teil-Genotyp repräsentiert dabei eine beliebige Eigenschaft des Individuums.
        Weiter können Teil-Genotypen wiederum in verschiedene weitere Teile aufgespalten werden.
        Damit entsteht die Möglichkeit, Individuen nach einem dynamisch generierten Bauplan zu erstellen
        und beliebige Kombinationen aus vorhandenen Teil-Genotypen innerhalb eines Genotyps zu bilden,
        ohne dass die Implementation der seed-Funktion angepasst werden muss.

      \subsubsection{Seeding\label{subsub:GenotypeSeeding}}

        Das zufällige Erstellen eines Genotyps wird ``seeding'' genannt.
        Zu Beginn der Simulation wird die initale Population mit zufällig generierten Individuen erstellt.
        Dabei ist es Hilfreich manche Parameter nicht zufällig generieren zu lassen,
        sondern mit einem fixen Wert zu initialisieren.
        Besonders der Bewegungsablauf kann so von Beginn an festgelegt werden.
        Deshalb wurde beim Seeding ein Ansatz gewählt, der es erlaubt flexibel jeden Teil-Genotyp separat mit
        spezifizierten Werten zu initialisieren.

      \subsubsection{Generierung Körperpunkte\label{subsub:GenotypeBodypointCreation}}

        Als erster Ansatz für die Generierung von Körperpunkten wurde ein Quadrat evaluiert.
        Dieser Ansatz wurde nicht weiter verfolgt,
        da der Ansatz mit einem Kreis für beliebig viele und ungerade Anzahlen von Punkten einfacher lösbar ist.

        \smallskip

        Die Generierung eines zufälligen Körpers läuft in mehreren Schritten ab.
        Als erstes wird definiert aus wie vielen Punkten \( n \) der Körper besteht.

        \[ 4 \leq n \leq 8 \]

        Anschliessend wird der Einheitskreis in \( n \) Sektoren unterteilt.
        Der Winkel \( \rho \) eines jeden Sektors entspricht:

        \[ \rho = \frac{2 * \pi}{n} \]

        Für jeden Sektor \( s_{i} \) werden ein zufälliger Radius \( r \) und ein zufälliger Winkel \( \phi \) gewählt.

        \begin{align*}
          r &= random(0, 1) \\
          \phi &= random(\rho * i, \rho * (i + 1)) \\
          P &= (r, \phi)
        \end{align*}

        Damit die Koordinaten in der Physik-Engine verwendet werden können,
        müssen die Koordinaten in kartesicher Form sein.
        Die Polarkooridnaten \( P \) werden in kartesische Koordinaten transformiert und miteinander verbunden.

        \smallskip

        Die folgende Abbildung~\ref{fig:kp} zeigt die Form eines Individuums mit 6 Körperpunkten.
        \\
        \begin{figure}[H]
          \centering
          \input{graphics/unit-circle-body-points}
          \caption{Berechnung Körperpunkt veranschaulicht\label{fig:kp}}
        \end{figure}

    \subsection{Phänotyp\label{sub:Phenotyp}}

      % TODO

      Der Phänotyp stell die Repräsentation des Genotyps in der Physik-Engine dar.
      Er setzt sich aus mehreren geometrischen Figuren zusammen.
      Die Beine des Individuums werden mit Hilfe eines Drehgelenks an den Körper gebunden.
      Auf allen Gelenken ist ein Rotationsmotor vorhanden, der verwendet wird zum eine Bewegung in Gang zu setzten.

    % =====================================================================
    % MOTOR
    % =====================================================================

    \subsection{Motor\label{sub:Engine}}



      Der Bewegungsablauf wird durch einen \gls{JointDriven} Bewegungsmotor realisiert.
      Der Bewegungsmotor kontrolliert die Bewegung eines Phänotyps indem die Motoren der Hüft- und
      Knie-Gelenke gesteuert werden.

      %
      % All movements
      %
      \begin{figure}[H]
        \centering

        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/00}
          \caption{\label{fig:ConceptMovement00}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/05}
          \caption{\label{fig:ConceptMovement05}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/10}
          \caption{\label{fig:ConceptMovement10}}
        \end{subfigure}

        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/15}
          \caption{\label{fig:ConceptMovement15}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/20}
          \caption{\label{fig:ConceptMovement20}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/30}
          \caption{\label{fig:ConceptMovement30}}
        \end{subfigure}

        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/35}
          \caption{\label{fig:ConceptMovement35}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/36}
          \caption{\label{fig:ConceptMovement36}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/40}
          \caption{\label{fig:ConceptMovement40}}
        \end{subfigure}

        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/45}
          \caption{\label{fig:ConceptMovement45}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/50}
          \caption{\label{fig:ConceptMovement50}}
        \end{subfigure}
        \hspace{\fill}
        \begin{subfigure}[b]{0.3\textwidth}
          \includegraphics[width=\linewidth,center]{graphics/movement/55}
          \caption{\label{fig:ConceptMovement55}}
        \end{subfigure}

        \caption{Bewegungsablauf\label{fig:ConceptMovementPhase12}}
      \end{figure}

      \subsubsection{Bewegungen\label{subsub:EngineMovements}}

        Dem Motor stehen verschiedene Kategorien von Bewegungen zur Verfügung.
        Es wird unterschieden zwischen:

        \begin{itemize}
          \item Einfache
          \item Zusammengesetzte
          \item Prädikate
        \end{itemize}

        \paragraph{Einfache Bewegung\label{EngineMovementsSimple}}

          Einfache Bewegungen werden dadurch charakterisiert,
          dass sie einen Parameter einer Extremität des Phänotyps verändern.
          \\
          Veränderbar sind die minimalen und maximalen Winkel eines Gelenkes und die Winkelgeschwindigkeit des
          Gelenk-Motors. Der Winkel des Gelenkes kann ebenfalls fixiert werden.
          \\
          Die maximale Winkelgeschwindigkeit des Gelenk-Motors ist limitiert.
          Dies stellt sicher, dass die vorhandene Kraft eines Phänotyps nach oben limitiert wird.
          \[ {\lvert} \omega_{\max} {\rvert} = 1\frac{rad}{s}\]
          \\
          Der minimale Winkel \(\alpha \) und der maximale Winkel \(\beta \) des Gelenks sind definiert als:
          \[ \alpha, \beta \in \mathbb{R}, -\pi \leq \alpha < \beta \leq \pi \]

        \paragraph{Zusammengesetzte Bewegung\label{EngineMovementsCompound}}

          Zusammengesetzte Bewegungen gruppieren eine beliebige Anzahl von Bewegungen zu einer einzigen.
          Dabei spielt es keine Rolle, von welchem Typ ein Element ist.
          Die ganze Gruppe der Bewegungen wird in einem Schritt der Physik-Engine ausgeführt.
          Damit können Bewegungen parallel abgearbeitet werden.
          \\
          Es stehen zwei Auswertungsfunktionen zur Verfügung:
          \begin{itemize}
            \item \textbf{Alle}: Jede Teil-Bewegungen in dieser Gruppe muss erfolgreich ausgeführt worden sein.
            \item \textbf{Eine}: Nur eine einzige Bewegung in dieser Gruppe muss erfolgreich ausgeführt worden sein.
          \end{itemize}

        \paragraph{Prädikate\label{EngineMovementsPredicates}}

          Dies Art der Bewegung führt keine Änderung am Zustand des Phänotyps durch.
          Nur der Zustand eines Attributes des Gelenkes wird geprüft.
          \\
          Eine Prädikat-Bewegung gilt als ausgeführt, wenn sie das spezifizierte Prädikat erfüllt.
          Hierfür stehen mehrere Prädikate wie maximaler oder minimaler Winkel erreicht zur Verfügung.

      \subsubsection{Ablauf}

        Die Implementation des Bewegungsmotors ist eine \acrfull{fsm}.
        Der Zustand des Bewegungsablaufs wird auf dem Phänotyp festgehalten.
        Es wird gespeichert, welche die aktuelle Bewegung ist.
        Jedes Individuum verfügt über einen eigenen Bewegungsablauf.
        \\
        Der Bewegungsablauf ist eine Liste von parametrisierbaren Bewegungen.
        Im Bewegungsmotor wird das jeweilige aktuelle Element verarbeitet
        während die Physik-Engine einen Zeitschritt ausführt.

      \subsubsection{Feedback}

        Zur weiteren Verbesserung des Bewegungsablaufs kann der Motor auf Rückmeldungen aus der Simulations-
        Welt zurückgreifen.
        Dabei können Kollisionen von Extremitäten mit dem Boden abgefangen und verarbeitet werden.
        \\
        Damit der Bewegungsmotor dynamisch auf Änderungen des Untergrundes reagieren kann,
        muss zusätzlich eine Rückmeldung an den Motor erfolgen, wenn sich die Art des Untergrundes ändert
        oder wenn ein Anstieg oder Abstieg bevorsteht.
        \\

    % =====================================================================
    % /MOTOR
    % =====================================================================



  \section{Auswahl des Evolutionären Algorithmus}

    Es stehen 4 Typen von Evolutionäre Algorithmen zur Auswahl:
    \begin{itemize}
      \item Genetische Algorithmen~(GA)~(\vref{item:genAlgo})
      \item Genetische Programmierung~(GP)~(\vref{item:genProg})
      \item Evolutionäre Programmierung~(EP)~(\vref{item:evProg})
      \item Evolutionäre Strategien~(ES)~(\vref{item:evStrat})
    \end{itemize}
    %Um die Problemstellung zu lösen, wurde entschieden Evolutionäre Programmierung einzusetzen
    Das Austauschen der Genen (Rekombination) ist wenig hilfreich bei der Lösung der Problemstellung.
    Man stelle sich dazu vor, dass das Gen welches den Körper definiert, mit dem des Motors vertauscht wird.
    So kann keine sinnvolle Evolution statt finde. Rekombination kann für die Verwendung somit ausgeschlossen werden.
    Dies stellt schon den ersten Indikator dafür da,
    dass Evolutionäre Programmierung eingesetzt werden kann.
    Ein weiteres Kriterium ist die genetische Repräsentation.
    Da unser Individuum sich aus Punkten im einem Koordinatensystem,
    verschiedene Winkel und einem Antrieb (Motor) definiert, wird die Reale-Werte-Repräsentation eingesetzt.
    Eine Baumrepräsentation oder binäre Repräsentation erscheint hier wenig hilfreich.
    Ein Punkt ist nichts anderes als zwei reale Werte,
    ein Winkel kann ebenfalls so beschrieben werden und ein Antrieb auch.
    Die Problemstellung würde wahrscheinlich anderst bewältigt werden,
    würde es hier um reale Kreaturen gehen und nicht nur um virtuelle Roboter,
    welche in einer künstlichen Umgebung (virtuelles Koordinatensystem) das Laufen lernen.
    Die Genetik ist in diesem Falle also vernachläsigbar.
    Schlussendlich wurde entschieden die Problemstellung, auf Grund der gelieferten Argumente, mit evolutionärer Programmierung zu lösen.

  \section{Eingesetzte Technologien\label{sec:Technology}}

    Zur Auswahl standen mehrere Programmiersprachen und Physik-Engines.
    Die Evaluationskriterien dabei waren:
    \begin{itemize}
      \item Platform-Interoperabilität (Linux, Windows Mac OS X)
      \item Einfache Handhabung
      \item Stabilität
      \item Funktionsumfang der Physik-Engine
      \item Ökosystem der Programmiersprache (verfügbare Bibliotheken)
    \end{itemize}

    % Ignore punctuation warning on '.NET'
    % chktex-file 26
    Als erstes wurde F\# und diverse populäre .NET Physik-Engines wie Farseer Physics,
    Physics 2D und Digital Rune Engine evaluiert.
    F\# ist eine funktionale Sprache die mit einer sauberen Syntax und einem der besten Typensystem überhaupt besticht.
    Jedoch gestaltete sich die Konfiguration und Platform-Interoperablität sehr schwierig.
    Dies lag nicht an den Physics Engines selber, sondern an der Open-Source-Implementierung Mono Game.
    Eine plattformübergreifende Konfiguration,
    so dass mit allen oben genannten Betriebssystemen entwickelt werden kann,
    konnte nicht erstellt werden.
    \\
    Als zweite Möglichkeit wurde Javascript und die Physik-Engine Matter.js und p2.js in Betracht gezogen.
    Die Popularität von Javascript hat in den letzten Jahren enorm zugenommen.
    Auch wurde mit dem neuen ECMA2015 Standard die Sprache enorm verbessert und viele neue Features eingeführt.
    Das Javascript-Ökosystem ist eines der grössten überhaupt.
    Da Javascript ursprünglich eine Webtechnologie ist und auf allen Plattformen problemlos läuft,
    wurde das Kriterium der Platform-Interoperabilität ohne zusätzliche Konfiguration erfüllt.
    Matter.js wirkte noch nicht so ausgereift wie p2.js und wies viele Fehler auf.
    Um Javascript und p2.js ohne Browser zu betreiben wird Electron eingesetzt.
    Electron ist node.js und Google Chrome vereint in einer Standalone-Anwendung.
    Mit Hilfe von Node.js lassen sich alle I/0-Zugriffe regeln und es kann auf den
    Node Package Manager zur Abhängigkeitsverwaltung von anderen Bibliotheken zurückgegriffen werden.
    Auch lässt sich unter bestimmten Umständen Javascript schneller ausführen unter Node.js als in einem Browser.

    \subsection{Programmierparadigma\label{sub:TechnologyParadigma}}

      In der Programmierung gibt es verschiedene Ansätze,
      wie der Quellcode aufgebaut werden soll und wie Probleme gelöst werden sollen.
      Die bekanntesten Ansätze sind prozedural, objektorientiert und funktional.

      \subsubsection{Prozedural\label{subsub:TechnologyParadigmaProzedural}}

        Prozedurale Programme bestehen aus einer Folge von Befehlen,
        die vorgeben wann was ausgeführt wird.
        Die Daten und die Routinen die mit diesen arbeiten, sind voneinander getrennt.

      \subsubsection{Objekt-Orientiert\label{subsub:TechnologyParadigmaObjectOriented}}

        Die objektorientierte Programmierung verbindet die Daten und
        die Routinen die mit diesen interagieren. Sie werden zu Einheiten zusammengefasst.
        Diese Einheiten werden im Zusammenhang mit Objekt-Orientierter-Programmierung Klassen genannt.

      \subsubsection{Funktional\label{subsub:TechnologyParadigmaFunctional}}

        Funktionale Programmierung heisst, das Programm so zu entwerfen, so dass die Datenverarbeitung nur aus Evaluationen von Funktionen besteht.
        Wenn Mutationen durchgeführt werden, wird anstatt die jeweilige Eigenschaft zu verändern,
        ein neues Objekt inklusive der Mutation zurückgegeben. Ohne mutable State ist es einfach Parallelisierung zu implementieren.
        Es wird anstatt Iterationen, Rekursionen verwendet.
        In der funktionalen Programmierung versucht man Funktionen die Nebeneffekte haben (globale Attribute) zu vermeiden.
        Dies hat den Vorteil, dass einzelne Funktionen viel einfacher zu testen sind, als bei der objektorientierten Programmierung.

      \subsection{Notwendige zusätzliche Implementierungen}

        Für die Erstellung des Terrains wird ein Höhenfeld von p2.js benutzt.
        Die Kollisionserkennung zwischen einem Höhenfeld und einem Polygon funktioniert nicht einwandfrei.
        Manche Polygonecken werden nicht berücksichtigt in der Kollisionserkennung.
        Das hat zur Folge, dass Körperteile der Individuen im Boden einsinken.
        \vref{fig:vorEinsinken} zeigt das Individuum vor dem Einsinken und \vref{fig:nachEinsinken} zeigt das Invidiuum mit der eingesunkenen Spitze.

        \begin{figure}[H]
          \centering
          \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[width=\linewidth,center]{graphics/physics-engine/sink-0}
            \caption{Vor dem Einsinken\label{fig:vorEinsinken}}
          \end{subfigure}
          \qquad
          \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[width=\linewidth,center]{graphics/physics-engine/sink-1}
            \caption{Nach dem Einsinken\label{fig:nachEinsinken}}
          \end{subfigure}
          \caption{Vor Korrektur}
        \end{figure}

        Kollisionen mit einem Höhenfeld werden am besten erkannt mit Kreisen.
        \vref{fig:noVorEinsinken} zeigt die Anbringung von kleinen Kreisne mit vernachlässigbarer Masse an den Ecken des Körpers und der Beine.
        Dies verbessert die Kollisionserkennung zwischen den Phänotypen und dem Untergrund.
        Wie in \vref{fig:noNachEinsinken} erkennbar sinkt die Spitze des Individuums nicht mehr in den Boden ein.
        Diese Optimierungen gehen zu Lasten eines erhöhten Rechenaufwands.

        \begin{figure}[H]
          \centering
          \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[width=\linewidth,center]{graphics/physics-engine/sink-fix-0}
            \caption{Individuum mit Kreisen\label{fig:noVorEinsinken}}
          \end{subfigure}
          \qquad
          \begin{subfigure}[b]{0.45\textwidth}
            \includegraphics[width=\linewidth,center]{graphics/physics-engine/sink-fix-1}
            \caption{Verhindern des Einsinkens\label{fig:noNachEinsinken}}
          \end{subfigure}
          \caption{Nach Korrektur}
        \end{figure}

  \section{Konfiguration\label{sec:Konfiguration}}

    Die Applikation lässt sich mit diversen Parametern konfigurieren.
    Es wird eine Konfigurationstabelle~(\vref{tbl:simulation-parameters-general}) eingeführt,
    welche auch im Kapitel Resultate~(\vref{chap:Resultate}) vewendet wird,
    um die jeweilige Konfiguration der Simulation fest. In der Konfigurationstabelle werden nur die Parameter erwähnt,
    welche relevant für den Algorithmus sind. Bei der allgemeinen Lösung wird der Parcours
    nach jeder Generation neu generiert. Bei der Evaluation auf Evolvierbarkeit
    wird der Parcours nur dann neu generiert, wenn sich die Schwierigkeit des Parcours ändert.

    \begin{table}[H]
      \input{tables/simulation-parameters-general.tex}
      \caption{Konfigurationstabelle Simulation\label{tbl:simulation-parameters-general}}
    \end{table}

    \subsection{Technische Parameter}
      Ein wichtiger technischer Parameter ist die Anzahl der eingesetzten Simulationsprozesse~(\vref{sec:Ablauf}).
      Durch die Erhöhung dieses Parameters kann von mehreren CPU-Kernen profitiert, somit lässt sich die Simulatiom~(\vref{sec:simulation}) und Mutation~(\vref{sec:Mutation}) parallelisieren.
      Optimal ist es diesen Wert auf die Anzahl verfügbarer CPU-Kerne zu setzen.
      Die Grösse des Zeitschritts~\cite{bullet:steppingTheWorld} der Physik-Engine lässt sich ebenfalls einstellen.
      %Wenn man den Zeitschritt halbiert muss die Relaxation mit dem Faktor 4 multipliziert werden.
      Die Relaxation kann auch konfiguriert werden. Der Parameter beschreibt die Anzahl von Zeitschritten um eine Constraint-Gleichung~\cite{gamedev:constraints} zu stabilisieren.
      Die Stiffness ist der letzte wichtige technische Parameter. Man kann sich die Stiffness als Steifheit einer Feder vorstellen.
      Sie beschreibt wie steif alle Element der Simulation sich verhalten sollen.


  \section{Ablauf\label{sec:Ablauf}}

    Der Ablauf der Applikation setzt sich aus mehreren Komponenten zusammen.
    Jeder dieser Komponenten kann man dem Haupt- oder Simulationsprozess zu ordnen~(\vref{fig:hauptSimuProzesse}).
    In~\vref{sub:domMod} sind die jeweiligen Zusammenhänge der Klassen und Objekte ausführlicher beschrieben.
    \vref{fig:ablauf} beschreibt den generellen Ablauf als Flussdiagramm

    \begin{figure}[H]
      \includegraphics[scale=0.45,center]{graphics/haupt_simulations_prozess}
      \caption{Haupt- und Simulationsprozess\label{fig:hauptSimuProzesse}}
    \end{figure}
    \begin{figure}[H]
      \includegraphics[scale=0.45,center]{graphics/ablauf}
      \caption{Ablauf der Simulation\label{fig:ablauf}}
    \end{figure}

    \subsection{Initiale Population\label{sec:Initiale Polulation}}

      Als erster Schritt muss eine initiale Population erstellt werden. Die Populationsgrösse kann frei gewhält werden.
      Pro Simulationsprozess können etwa 15 Individuuen flüssig berechnet werden.
      Dies bedeutet das die optimale Populationsgrösse  \( Anzahl(CPU Kerne) * 15 \) beträgt.
      Dieser Wert wurde durch mehrere Versüche mit unterschiedlichen CPUs gefunden.
      Es werden jeweils Individuen mit 4, 5, 6, 7 und 8 Körperpunkten~(\vref{sub:DesignBody}) generiert.
      Die Verantwortliche Klasse in Javascript ist der InitialPopulationGenerator.
      Das Endprodukt dieses Schrittes ist eine Population bestehenden aus den Genotypen der Individuen.

    \subsection{Parcours-Generierung\label{sec:Parcour Generierung}}

      Der Parcours wird zufällig generiert. Am Anfang wird ein einfacher und flacher Parcours generiert.
      Mit zunehmenden Iterationen steigt die Schwierigkeit des Parcours,
      dass heisst es werden höhere Steigungen und Punkte mit höheren Y-Koordinaten vorkommen.
      \vref{fig:parcours1},~\vref{fig:parcours2} und~\vref{fig:parcours3} zeigen wie der Parcours mit zunehmenden Generationen schwieriger wird.
      Dazu muss eine Klasse erstellt werden (ParcourGenerator),
      welche mit Hilfe von Obergrenzen von Werten einen Parcours generieren kann.
      Wie unter~\ref{sec:Konfiguration} erwähnt,
      wird je nach Einstellung der Parcours nach jeder Generation neu generiert oder er wird wiederverwendet
      bis ein Abbruchkriterium eintritt.
      Der Parcours wird im ParcourGenerator generiert (Haupt Prozess) und
      von den jeweiligen Worker mit Hilfe vom ParcourCreator in der Physik Engine erstellt.

      \vspace{1cm}

      \begin{figure}[H]
        \centering
        \input{graphics/parcours-1}
        \caption{flacher Start-Parcour 1. Generation\label{fig:parcours1}}
      \end{figure}

      \begin{figure}[H]
        \centering
        \input{graphics/parcours-2}
        \caption{Parcour 100. Generation\label{fig:parcours2}}
      \end{figure}

      \begin{figure}[H]
        \centering
        \input{graphics/parcours-3}
        \caption{Parcour 1000. Generation\label{fig:parcours3}}
      \end{figure}

      \subsection{Simulation\label{sec:simulation}}

      Nachdem eine neue Population und ein neuer Parcours erstellt worden ist.
      Muss eine Simulation durchgeführt werden um den Fitnesswert der Individuen zu bestimmen.
      Die Verantwortliche Klasse ist die SimulationWorld.
      Zuerst muss jeder Genotyp zu einem Phänotyp abgebildet werden.
      Anschliessend muss der Parcours aus dem Blueprint erstellt werden.
      Erst dann kann mit der Simulation begonnen werden.
      Die Simulation merkt sich zu jedem Individuum die Position.
      Individuen welche sich während 4 Sekunden kaum bewegt haben,
      werden aus der Simulation entfernt und ihr Fitnesswert wird abgespeichert.
      Die Simulation kann wie unter~\ref{sec:Konfiguration} schon erwähnt, parallelisiert werden. \\
      Es wird dann jeweils für \( Populationsgrösse / Anzahl Simulationsprozesse \) Individuen eine eigene Simulation erstellt.
      Die Kommunikation zwischen Simulationsprozessen und Hauptprozess erfolgt über asynchrones Messaging.

    \subsection{Reporting\label{subsec:Reporting}}

      Das Reporting-Modul hilft nach einer Simulation alle wichtigen Daten festzuhalten.
      Mithilfe einer Funktion die eine Population als Parameter entgegennimmt,
      werden die Reports erstellt. Es existieren folgende Typen von Reports:
      \begin{itemize}
        \item Fitness Graph Average Report: Enthält Koordinaten um einen Graph über die durchschnittliche Fitness pro Generation zu erstellen.
        \item Fitness Graph Best Report: Enthält Koordinaten um einen Graph über das beste Individuum der Generation zu erstellen.
        \item Genotype Blue Print Report: Enthält pro Generation ein \gls{JSON} das Informationen über die ganze Population enthält.
        \item Fitness Graph Average Report bp x: Für diesen Typ von Report gibt es jeweils einen für alle Individuen mit Body Points Anzahl x.
              Ansonsten gleich wie der Fitness Graph Average Report.
        \item Diversity Report: Enthält die Berechnung der Punktstreuung für jeweils eine Generation. Die Punktstreuung berechnet sich wie folgt:
        \begin{itemize}
          \item Erstellung von Vektoren der Genome. Jede Eigenschaft des Genoms wird in einen numerischen Wert konvertiert. \( V_d \)
          \item Alle Vektoren werden summiert.  Die Summe wird als \(V_s\) bezeichnet.
          \item Der Schwerpunktvektor wird gebildet: \( V_s / Anzahl(V_d) = V_{schwer} \)
          \item Von jedem \(V_d\) wird \(V_{schwer}\) subtrahiert  \( V_d - V_{schwer}  = V_{d2} \)
          \item Nun werden alle \(V_{d2}\) normiert, quadriert \( norm{(V_{d2})}^2 = d \)
          \item Abschliessend werden alle \(d\) zusammengezählt und durch \(Anzahl(V_d)\) dividiert. So erhält man ein Mass für die Punktestreuung.
        \end{itemize}
      \end{itemize}

    \subsection{Selektion\label{sec:Selektion}}
      D. Floreano und C. Mattiussi~\cite[S.33]{book:bioInspired} schreiben, dass Turnierbasierte-Selektion oft bei evolutinärer Programmierung eingesetzt wird.
      Turnierbasierte-Selektion hat den Vorteil, dass die Diversität erhalten bleibt,
      bei gleichzeitig guter Selektion der fittesten Individuen.
      Auf Grund der Empfehlung von D. Floreano und C. Mattiussi und der Erhaltung der Diversität wurde entschieden, Turnierbasierte-Selektion einzusetzen.

    \subsection{Mutation\label{sec:Mutation}}

      Auf die Selektionsstrategie folgt nun die Mutation der Individuen.
      Bei der Mutation wird über jede Eigenschaft des Individuums iteriert und
      diese wird mit einer bestimmten Wahrscheinlichkeit (PROBABILITY) und um einen bestimmten Wert (STEP) verändert.
      PROBABILITY kann Werte zwischen 0 und 1 annehmen, STEP hat keine Einschränkungen.
      Nachdem für jedes Attribut diese Werte definiert worden sind, kann die Mutation stattfinden.
      Limiten~(\vref{sub:IntroReqLimit}) wurden definiert, um nicht gewinnbringende Lösung zu verhindern.
      Die Position eines Beins wird unter einer zusätzlichen Bedingung mutiert. Falls sich der Körper so verändert hat,
      dass ein Bein ausserhalb des Körpers ist, wird die Position zufällig neu bestimmt.
      Die Mutation läuft wie die Simulation parallel ab, das heisst, sie kann von mehreren CPU-Kernen profitieren.

    \subsection{Abbruchkriterium}

      Der evolutinäre Algorithmus wird solange ausgeführt, bis der Anwender sich entscheidet ihn abzubrechen.
      Theoretisch wäre es auch möglich abzubrechen, wenn ein bestimmer Fitnesswert erreicht wird.
      Jedoch ist so mehr Flexibilität gewährleistet, der Anwender kann fortzu die Reports überprüfen und entscheiden
      ob die Individuen den Ansprüchen genügen.

    \subsection{Domänenmodel\label{sub:domMod}}

      Das Domänenmodell beschreibt den Zusammenhang der verschiedenen Klassen und Objekten.
      Abbildung~\ref{fig:mainProcess} beschreibt den Haupt- und Abbildung~\ref{fig:simulationProcess} den Simulationsprozess.
      \begin{figure}[H]
        \includegraphics[scale=0.6,center]{graphics/main_process}
        \caption{Domänen Modell, Hauptprozess\label{fig:mainProcess}}
      \end{figure}
      \begin{figure}[H]
        \includegraphics[scale=0.6,center]{graphics/simulation_process}
        \caption{Domänen Modell, Simulationsprozess\label{fig:simulationProcess}}
      \end{figure}
