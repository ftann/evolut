%
% Method
%

% !TEX root = ../../main.tex

\chapter{Methode}

  \todo[inline]{Beschreibt die Grundüberlegungen der realisierten Lösung (Konstruktion/Entwurf) und die
  Realisierung als Simulation, als Prototyp oder als Software-Komponente}
  \todo[inline]{Definiert Messgrössen, beschreibt Mess- oder Versuchsaufbau, beschreibt und dokumentiert
  Durchführung der Messungen/Versuche}
  \todo[inline]{Experimente}
  \todo[inline]{Lösungsweg}
  \todo[inline]{Modell}
  \todo[inline]{Tests und Validierung}
  \todo[inline]{Theoretische Herleitung der Lösung}

  \section{Design der Individuen}

    \subsection{Körper\label{sub:Körper}}

      Die erste Frage welche sich stellt ist, wie kann der Koerper am besten beschrieben werden? \\
      Der Koeper setzt sich aus verschiedenen Punkten auseinander.
      Die mindest Anzahl solcher Punkte wird auf 4 in einem ersten Schritt festgelegt. \\
      Die Obergrenze bei 8. Dies erlaubt dem Koeper eine polygonartige Figur.

      \subsubsection{Hyptohese Körperpunkte\label{subsub:hypoKp}}

        Es wird die Hypothese aufgestellt,
        dass sich ein Indiviuum mit 8 Körperpunkten schneller durch den Parcour bewegen kann,
        als ein Individuum mit weniger Körperpunkten.
        Die Vermutung dabei ist, dass durch die komplexere Form des Indiviuum, es besser die Balance halten kann.
        Ob dies zutrifft wird in Kapitel~\ref{chap:Resulate} diskutiert.

    \subsection{Beine\label{sub:Beine}}

      Insgesammt weissen die Individuuen 6 Beine auf. Ein Beinpaar ist symmetrisch. Ein Bein hat jeweils 2 Gelenke,
      eines welches es mit dem Koerper verbindet,
      das andere welches Ober- mit Unterschenkel verbindet.
      Als Vereinfachung wird die Hoehe des Gelenkes 0 gesetzt  \(h_{a} = 0\)
      Das Bein weisst eine Hoehe \(h_{l}\) auf. Die Position des Gelenkes,welches die beiden Beinschenkel verbindet,
      wird als Abstand zum oberen Ende des Oberschenkel definiert \(h_{t}\),
      andersrum gesagt ist das die Hoehe des Oberschenkels.
      Die Hoehe des Unterschenkels wird als \(h_{s}\) bezeichnet.
      Ein Bein weisst eine Breite auf \(w_{l}\). Am Ende des Unterschenkels wird ein Stumpf angehaengt.

      \subsubsection{Masse\label{subs:Masse}}

        Das ganze Individum weisst eine fixe Masse von 1 auf \(m = 0\).
        Die Masse wird aber auf die einzelnen Koerpeteile verteilt.
        \\
        \input{graphics/concept-leg}

    \subsection{Genotyp\label{sub:Genotype}}

      % TODO ramda, lenses

      \subsubsection{Design\label{subsub:GenotypeDesign}}

        Der Anspruch an das Design des Genotyps ist möglichst modular und einfach zu sein.
        Als Grund für ein modulares Design spricht die Erweiterbarkeit und Wiederverwendung der bestehenden Teile.
        Deshalb wurde der Genotyp in Teil-Genotypen unterteilt.
        Ein Teil-Genotyp repräsentiert dabei eine beliebige Eigenschaft des Individuums.
        Weiter können Teil-Genotypen wiederum in verschiedene weitere Teile aufgespaltet werden.
        Damit entsteht die Möglichkeit Individuen nach einem dynamisch generierten Bauplan zu erstellen
        und beliebige Kombinationen aus vorhandenen Teil-Genotypen innerhalb eines Genotypes zu bilden,
        ohne dass die Implementation der seed-Funktion angepasst werden muss.

        \subsubsection{Seeding\label{subsub:GenotypeSeeding}}

          Die initiale Population wird zufällig erstellt. Dieser Vorgang wird Seeding genannt.
          Dabei wird eine Anzahl von Individuen zufällig generiert.
          Unter gewissen Umständen ist es jedoch hilfreich gewisse Parameter nicht zufällig generiern zu lassen
          sondern mit einem fixen Wert zu initialisieren.
          Besonders der Bewegungsablauf kann so von Beginn an festgelegt werden.
          Deshalb wurde beim Seeding ein Ansatz gewählt, der es erlaubt flexibel jeden Teil-Genotyp separat mit
          spezifizierten Werten zu initialisieren.

      \subsubsection{Generierung Körperpunkte\label{subsub:GenotypGenerierungKörperpunkte}}
        Es werden Körper mit 4--8 Punkten generiert. Dazu wird der Einheitskreis in 4--8 Sektoren untertteilt.
        Der Winkel eines Sektors entspricht \(\pi / Anzahl Punkte\). \\
        Anschliessend wird in jedem Kreissektor mit Hilfe von Polar Korrdinaten ein Punkt bestimmt. \\
        \( r = random (0, 1), winkel = random(startSektorWinkel, endeSektorWinkel ) \)
        Anschliessend werden die Poolarkordinaten in kartesische Koordinaten transformiert.
        Die Punkte verbunden, ergeben den Körper des Individuum. \\
        Zuerst wurde ein Ansatz mit einem Quadrat evaluiert, bei diesem stellte sich jedoch die zufällige Bestimmung
        der Punkte als viel schwerer als mit einem Einheitskreis heraus. Der Nachteil unserer gewählten
        Ansatzes ist, dass eine quadratische Form nur angenähert werden kann.
        Die folgende Abbildung zeigt die Punkte eines Invidiuum mit 6 Körperpunkten: \\

        \input{./graphics/unit-circle-body-points}


  \subsection{Phenotyp\label{sub:Phenotyp}}
    Der Phenotyp stell die Repräentation des Genotyps in der Physik Engine dar.
    Er setzt sich aus mehreren geometrischen Figuren zusammen. Die Beine des Individuums
    werden mit Hilfe eines sogenannten Revolute Contraint an den Körper gebunden.
    Ebenso wird der Ober- mit dem Unterschenkel mit solch einem Constraint verbunden.
    Auf allen Revolute Contraint wird ein Rototationsmotor für die Bewegung definiert.

  \subsection{Engine\label{sub:Engine}}

    Die Bewegungs-Engine kontrolliert die Bewegung eines Phenotypes.
    Konkreter werden die Hüft- und Knie-Gelenke und deren Motoren kontrolliert.
    Dabei definiert eine Bewegnug z.B. wann ein Winkel eines Gelenkes gehalten werden muss
    oder wann der Motor des Gelenkes in welche Richtung in Bewegung gesetzt werden soll.
    \\
    Der Zustand des Bewegungsablaufs wird auf dem Phenotyp festgehalten.
    Es wird gespeichert welche die aktuelle Bewegung ist.
    Die Implementation der Bewegungs-Engine ist eine Finite State Machine (FSM),
    die in gewissen Zuständen stehen bleiben kann.
    \\
    Jedes Individuum verfügt über einen eigenen Bewegungsablauf.
    Der Bewegungsablauf ist eine Liste von parametrisierten Bewegugnen.
    Dieser wird in die Bewegungs-Engine eingespeist.

    \subsubsection{Bewegung\label{subsub:EngineMovement}}

      Eine Bewegung ist ein Zustand der Bewegungs-Engine.
      Sie legt fest, wann zum nächsten Zustand gewechselt werden kann.
      Unter einer Bewegung wird das Setzten der maximalen und minimalen Auslenkungswinkel oder auch
      das Warten auf einen Zustand eines Gelenkes verstanden.

  \section{Auswahl des Evolutinären Algorithmus}

    Es stehen 4 Typen von Evolutionäre Algorithmen zur Auswahl:
    \begin{itemize}
      \item Genetische Programmierung~\ref{item:genProg}
      \item Genetischer Algorithmus~\ref{item:genAlgo}
      \item Evolutiäre Strategie~\ref{item:evStart}
      \item Evolutinäre Programmierung~\ref{item:evProg}
    \end{itemize}
    \todo[inline]{Genauer Ausführen warum}
    Um die Problemstellung zu lösen, wurde entschieden Evolutinäre Programmierung einzusetzten.
    Warum Evolutinäre Programmierung eingesetzt wird, wird nachfolgend erläutert.
    Das Austauschen der Genen, Rekombination, macht keinen Sinn wenn man Individuen das Laufen beibringt.
    Man stelle sich dazu vor, man tausche das Gen welches den Körper definiert, mit dem der Beine.
    Dies stellt schon den ersten Indikator dafür da,
    dass Evolutionäre Programmierung eingesetzt werden kann. Ein weiteres Kriterium ist die genetische Repräsentation.
    Da unser Indiviuum sich aus Punkten im einem Koordinatensystem,
    verschiedene Winkel und einem Antrieb (Motor) definiert, wird die reale Werte Repräsentation eingesetzt.
    Eine Baumrepräsenation oder binäre Repräsentation erscheint hier wenig gewinnbringend.
    Ein Punkt ist nichts anderes als zwei reale Werte,
    ein Winkel kann ebenfalls so beschrieben werden und ein Antrieb auch.
    Die Problemstellung würde wahrscheinlich anderst bewältigt werden,
    würde es hier um reale Kreaturen gehen und nicht nur um virtuelle Roboter,
    welche in einer künstlichen Umgebung (virtuelles Koordinatensystem) das Laufen lernen.

  \section{Eingesetzte Technologien}

    Zur Auswahl standen mehrere Programmiersprachen und Physik Engines. Die Evaluationskriterien dabei waren:
    \begin{itemize}
      \item Platform-Interoperabilität (Linux, Windows Mac OS X)
      \item Einfache Handhabung
      \item Stabilität
      \item Funktionsumfang der Physik-Engine
      \item Ökosystem der Programmiersprache (verfügbare Bibilotheken)
    \end{itemize}

    % Ignore punctuation warning on '.NET'
    % chktex-file 26
    Als erstes wurde F\# und diverse populäre .NET Physics Engines wie Farseer Physics, Physics 2D und Digital Rune Engine evaluiert. % chktex-ignore
    F\# ist eine neue funktionale Sprache die mit einer sauberen Synatx und einem der besten Typensystem überhaupt besticht.
    Jedoch gestaltete sich die Konfiguration und Platform Interoperablität sehr schwierig. Dies lag nich an den Physic Engines selber,
    sondern an der Open Source Implementiertung Mono Game. Eine plattformübergreifende Konfiguration,
    damit mit allen oben genannten Betriebssystemen entwickelt werden kann, konnte nicht erstellt werden.\\
    Als zweite Möglichkeit wurde JavaScript und die Physics Engines Matter.js und p2.js in Betracht gezogen.
    Die Popularität von JavaScript hat in den letzten Jahren enorm zugenommen.
    Auch wurde mit dem neuen ECMA2015 Standard die Sprache enorm verbessert und viele neue Features eingeführt. Das JavaScript Ökosystem ist eines der grössten überhaupt.
    Da JavaScript eine Webtechnologie ursprünglich ist und auf allen Plattformen problemlos läuft, wurde das Kriterium der Platform Interoperabilität ohne zusätzliche Konfiguration erfüllt.
    Matter.js wirkte noch nicht so ausgereift wie p2.js und wies viele Fehler auf. Um JavaScript und p2.js ohne Browser zu betreiben wird Electron eingesetzt.
    Electron ist nicht anderes als Node.js und Google Chrome vereint in einer Standalone Anwendung.
    Mit Hilfe von Node.js lassen sich alle I/0 Zugriffe regeln und es kann auf den Node Package Manager zur Abhänigskeitsverwaltung von anderen Bibliotheken zurück gegriffen werden.
    Auch lässt sich unter bestimmten Umständen JavaScript schneller ausführen unter Node.js als in einem Browser.

  \section{Initiale Polulation\label{sec:Initiale Polulation}}

    Als erster Schritt muss eine initiale Population erstellt werden. Die Populationsgrösse wird auf 100 festgelegt,
    um eine breite Diversität zu erhalten.
    Es werden jeweils 20 Individuen mit 4,5,6,7 und 8 Körperpunkten~\ref{sub:Körper} generiert.
    Die Verantwortliche Klasse in JavaScript ist der InitialPopulationGenerator.

  \section{Parcour Generierung\label{sec:Parcour Generierung}}

    Der Parcour wird zufällig generiert. Am Anfang wird ein einfacher und flacher Parcour generiert.
    Mit zunehmenden Iterationen steigt die Schwierigkeit des Parcours, das heisst es werden höhere Steigungen, ein höherer Punkt und XYZ vorkommen.
    Dazu muss eine Klasse erstellt werden (ParcourGenerator), welche mit Hilfe von Obergrenzen von Werten einen Parcour generieren kann.

  \section{Selektion\label{sec:Selektion}}

    Als Seleketionsstrategie wird Tournament-based Selection eingesetzt. Tournamend-based Selection hat den Vorteil,
    dass die Diversität erhalten bleibt, bei gleichzeitig guter Selektion der fittesten Individuen.

    \subsection{Hypothese Selektionsstratgegie\label{sub:Hypothese Selektionsstratgegie}}

      Es wird die Hypothese aufgestellt, dass Tournament-based-Selection die besseren Resulate liefert im Vergleich zu den folgenden Selektionsstrategien: X und Y.
      Um dies zu validieren werden die Selektionsstrategien X und Y implementiert und anschliessend analysiert.
      Ob dies zutrifft wird in Kapitel~\ref{chap:Resulate} diskutiert.

  \section{Mutation\label{sec:Mutation}}

    Auf die Selektionsstrategie folgt nun die Mutation der Individuen.
